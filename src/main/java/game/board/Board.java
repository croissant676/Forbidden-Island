package game.board;

import game.Visualizable;
import utils.FullyImplemented;

import javax.swing.*;
import java.awt.*;
import java.util.*;
import java.util.List;

/** Represents the Board in the game.
 * The board stores things such as pawn locations,
 * Tile locations, and other various things. It does not store
 * the value of the water meter though.
 * @since 1.0.0
 * @author Kason
 * @see Tile tile
 * @see Visualizable
 * */
@SuppressWarnings("unused")
public class Board implements Visualizable {

    private final Tile[][] tiles;

    /** Constructs a board with its tiles generated by a
     * random with the given seed. Inputting the same
     * seed into this constructor should result in the same
     * board layout and the same result.
     * @since 1.0.0
     * */
    @FullyImplemented
    public Board(long seed) {
        tiles = new Tile[6][6];
        List<TileType> tileTypes = new ArrayList<>(List.of(TileType.values()));
        Collections.shuffle(tileTypes, new Random(seed));
        byte number = 0;
        for (byte row = 0; row < 6; row++) {
            for (byte col = 0; col < 6; col++) {
                byte sum = (byte) (row + col);
                if (sum > 1 && sum < 9 && Math.abs(row - col) < 4) {
                    tiles[row][col] = new Tile(row, col, tileTypes.get(number++));
                }
            }
        }
    }

    /** Returns a tile if the specified location is a valid index. If not,
     * this method will return <tt>null</tt>.
     * @return A tile if the specified location is a valid index, or null if not.
     * @param row Row of the location
     * @param col Column of the location
     * @since 1.0.0
     * */
    @FullyImplemented
    public Tile getTileAt(int row, int col) {
        if (isValidIndex(row, col)) {
            return tiles[row][col];
        } else {
            return null;
        }
    }

    /** Returns a tile if the specified location is a valid index. If not,
     * this method will throw an <tt>IllegalArgumentException</tt>.
     * @return A tile if the specified location is a valid index.
     * @param row Row of the location
     * @param col Column of the location
     * @since 1.0.0
     * */
    @FullyImplemented
    public Tile getTileAtOrError(int row, int col) {
        if (isValidIndex(row, col)) {
            return tiles[row][col];
        } else {
            throw new IllegalArgumentException("Location [" + row + ", " + col + "] is outside of the board.");
        }
    }

    /**
     * Returns whether the specified location is a valid index.
     * @since 1.0.0
     * @param row Row of the location
     * @param col Column of the location
     * @return Whether the specified location is a valid index.
     * */
    @FullyImplemented
    public boolean isValidIndex(int row, int col) {
        return row >= 0 && row < 6 && col >= 0 && col < 6;
    }

    /** Returns the array of tiles for this board.
     * @since 1.0.0
     * @return The array of tiles for this board.
     * */
    @FullyImplemented
    public Tile[][] getTiles() {
        return tiles;
    }

    /** Returns the list of tiles which have not sunk.
     * @since 1.0.0
     * @return The list of tiles which have not sunk.
     * */
    public List<Tile> getRemainingTiles() {
        return null;
    }

    /** Returns a string representation of this board.
     * Mostly used for debugging purposes.
     * @since 1.0.0
     * @return A string representation of this board.
     * */
    @Override
    @FullyImplemented
    public String toString() {
        StringBuilder builder = new StringBuilder();
        for (int row = 0; row < 6; row++) {
            for (int col = 0; col < 6; col++) {
                Tile tile = tiles[row][col];
                if (tile == null) {
                    builder.append(" ".repeat(15));
                } else {
                    String str = tile.shortened();
                    builder.append(str).append(" ".repeat(15 - str.length()));
                }
            }
            if (row < 5) {
                builder.append('\n');
            }
        }
        return builder.toString();
    }

    /** Returns a visual representation of this board.
     * Used in the game's actual UI.
     * Relies on the UI generated by the tiles.
     * @since 1.0.0
     * @return A visual representation of this board.
     * @see Visualizable#getVisual()
     * */
    @Override
    @FullyImplemented
    public JComponent getVisual() {
        JPanel panel = new JPanel();
        GridLayout layout = new GridLayout();
        panel.setLayout(layout);
        for (int row = 0; row < 6; row++) {
            for (int col = 0; col < 6; col++) {
                if(getTileAt(row, col) == null) {
                    JButton button = new JButton();
                    button.setPreferredSize(new Dimension(50, 50));
                    panel.add(button, row, col);
                } else {
                    panel.add(getTileAt(row, col).getVisual());
                }
            }
        }
        return panel;
    }
}

